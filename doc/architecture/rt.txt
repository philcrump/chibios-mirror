/*
    ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
              2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.

    This file is part of ChibiOS.

    ChibiOS is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3 of the License.

    ChibiOS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @startuml {rt_arch.png} "RT Core"
 * package "Lists and Queues" {
 *   class ch_list_t {
 *     - next: ch_list_t *
 *     + ch_list_init()
 *     + ch_list_isempty()
 *     + ch_list_notempty()
 *     + ch_list_push()
 *     + ch_list_pop()
 *   }
 *   class ch_queue_t {
 *     - next: ch_queue_t *
 *     - prev: ch_queue_t *
 *     + ch_queue_init()
 *     + ch_queue_isempty()
 *     + ch_queue_notempty()
 *     + ch_queue_insert()
 *     + ch_queue_fifo_remove()
 *     + ch_queue_lifo_remove()
 *     + ch_queue_dequeue()
 *   }
 *   class ch_pqueue_t {
 *     # next: ch_pqueue_t *
 *     # prev: ch_pqueue_t *
 *     # prio: tprio_t
 *     + ch_pqueue_init()
 *     + ch_pqueue_fifo_remove_highest()
 *     + ch_pqueue_insert_ahead()
 *     + ch_pqueue_insert_behind()
 *   }
 * }
 * 
 * package OS {
 *   class "Port Layer" <<(S,#FF7700) Singleton>> {
 *     + {static} port_init()
 *     + {static} port_lock()
 *     + {static} port_unlock()
 *     + {static} port_suspend()
 *     + {static} port_enable()
 *     + {static} port_disable()
 *     + {static} port_switch()
 *     + {static} port_timer_get_time()
 *   }
 *   class System <<(S,#FF7700) Singleton>> {
 *     - {static} ch_system : ch_system_t
 *     - {static} ch0 : os_instance_t
 *     - {static} ch1 : os_instance_t
 *   }
 *   class tm_calibration_t {
 *     # __tm_calibration_object_init()
 *   }
 *   class system_debug_t {
 *     # __dbg_object_init()
 *   }
 *   class trace_buffer_t {
 *     # __trace_object_init()
 *   }
 *   class kernel_stats_t {
 *     # __stats_object_init()
 *   }
 *   class registry_t {
 *     - queue : ch_queue_t
 *     # __reg_object_init()
 *     + {static} chRegFirstThread()
 *     + {static} chRegNextThread()
 *     + {static} chRegFindThreadByName()
 *     + {static} chRegFindThreadByPointer()
 *     + {static} chRegFindThreadByWorkingArea()
 *   }
 *   class ch_system_t <<used by all>>{
 *     + state : ch_system_state_t
 *     - reglist : registry_t
 *     - tmc : tm_calibration_t
 *     - instances[] : os_instance_t *
 *     + {static} chSysInit()
 *     + {static} chSysLock()
 *     + {static} chSysUnlock()
 *     + {static} chSysLockFromISR()
 *     + {static} chSysUnlockFromISR()
 *     + {static} chSysSwitch()
 *   }
 *   class os_instance_t {
 *     # rlist : ready_list_t
 *     # vtlist : virtual_timers_list_t
 *     # reglist : registry_t
 *     # mainthread : thread_t
 *     # dbg : system_debug_t
 *     # trace_buffer : trace_buffer_t
 *     # kernel_stats : kernel_stats_t
 *     + chInstanceObjectInit()
 *   }
 *   class thread_t {
 *     .. union ..
 *     - list : ch_list_t
 *     - queue : ch_queue_t
 *     - pqueue : ch_pqueue_t
 *     .. end union ..
 *     - owner : os_instance_t
 *     - rqueue : ch_queue_t
 *     - ctx : port_context
 *     - waiting: ch_list_t
 *     + {static} chThdCreate()
 *     + {static} chThdSleep()
 *     + {static} chThdSleepUntil()
 *     + {static} chThdExit()
 *     + chThdWait()
 *     + chThdAddRef()
 *     + chThdRelease()
 *   }
 *   class ready_list_t {
 *     - pqueue : ch_pqueue_t
 *     - current : thread_t *
 *     + {static} chSchReadyI()
 *     + {static} chSchWakeupS()
 *     + {static} chSchGoSleepS()
 *     + {static} chSchGoSleepTimeoutS()
 *   }
 * }
 * 
 * OS ..> "Lists and Queues" : use
 * ch_system_t .u.> "Port Layer" : use
 * System *-- "1" ch_system_t : system\nroot object
 * System *-- "1..2" os_instance_t
 * ch_system_t *-- "1" registry_t : SMP\nonly
 * ch_system_t *-- "1" tm_calibration_t
 * ch_system_t o-- "1..*" os_instance_t : registered\ninstances
 * os_instance_t *-- "1" thread_t : Main\nThread
 * os_instance_t *-- "1" registry_t : Non-SMP\nonly
 * os_instance_t *-- "1" system_debug_t
 * os_instance_t *-- "1" trace_buffer_t
 * os_instance_t *-- "1" kernel_stats_t
 * 
 * thread_t o-- "0..*" thread_t : threads waiting\nfor termination
 * thread_t o-- "1" os_instance_t : owner\ninstance
 * thread_t "1..*" --o registry_t : alive\nthreads
 * ready_list_t o-- "1..*" thread_t : ready\nthreads
 * ready_list_t o-- "1" thread_t : current\nthread
 * ready_list_t "1" --* os_instance_t : instance\nready list
 * 
 * package "Virtual Timers" {
 *   class delta_list_t {
 *     - next : delta_list_t *
 *     - prev : delta_list_t *
 *     - delta : sysinterval_t
 *   }
 *   class virtual_timer_t {
 *     - dlist : delta_list_t
 *     - func : vtfunc_t
 *     - par : void *
 *     + chVTObjectInit()
 *     + chVTSet()
 *     + chVTReset()
 *   }
 *   class virtual_timers_list_t {
 *     - dlist : delta_list_t
 *     - systime : systime_t
 *     - lasttime : systime_t
 *     - laststamp : uint64_t
 *     # __vt_object_init()
 *   }
 * }
 * 
 * virtual_timer_t <.. ready_list_t : use
 * virtual_timer_t *-- "1" delta_list_t
 * virtual_timers_list_t o-u- "0..*" virtual_timer_t : active timers
 * virtual_timers_list_t *-u- "1" delta_list_t
 * virtual_timers_list_t "1" --* os_instance_t
 * 
 * @enduml
 *
 * @startuml {rt_arch.png} "RT Synchronization"
 * class CoreAPI <<(S,#FF7700) Singleton>> {
 * }
 * package Synchronization {
 *   class thread_reference_t {
 *     # ref : thread_t *
 *     + chThdSuspendS()
 *     + chThdSuspendTimeoutS()
 *     + chThdResumeI()
 *     + chThdResumeS()
 *   }
 *   class thread_queue_t {
 *     + chThdQueueObjectInit()
 *     + chThdEnqueueTimeoutS()
 *     + chThdDequeueNextI()
 *     + chThdDequeueAllI()
 *   }
 *   class semaphore_t {
 *     # cnt : cnt_t
 *     + chSemObjectInit()
 *     + chSemWait()
 *     + chSemWaitTimeout()
 *     + chSemSignal()
 *     + chSemReset()
 *   }
 *   class mutex_t {
 *     # owner : thread_t *
 *     # next : mutex_t *
 *     # cnt : cnt_t
 *     + chMtxObjectInit()
 *     + chMtxLock()
 *     + chMtxTryLock()
 *     + chMtxUnlock()
 *     + chMtxUnlockAll()
 *   }
 *   class condition_variable_t {
 *     + chCondObjectInit()
 *     + chCondSignal()
 *     + chCondBroadcast()
 *     + chCondWait()
 *     + chCondWaitTimeout()
 *   }
 * }
 * package Messages {
 *   class events {
 *     + chEvtObjectInit()
 *     + chEvtRegister()
 *     + chEvtBroadcastFlags()
 *     + {static} chEvtSignal()
 *     + {static} chEvtWaitOne()
 *     + {static} chEvtWaitAny()
 *     + {static} chEvtWaitAll()
 *     + {static} chEvtDispatch()
 *   }
 *   class messages <<(S,#FF7700) Singleton>> {
 *     + {static} chMsgWait()
 *     + {static} chMsgGet()
 *     + {static} chMsgRelease()
 *     + {static} chMsgSend()
 *   }
 * }
 * 
 * thread_reference_t o-- "0..1" thread_t
 * thread_reference_t ..> CoreAPI : use
 * 
 * thread_queue_t o-- "0..*" thread_t : queued
 * thread_queue_t ..> CoreAPI : use
 * 
 * thd_queue_t <|-- thread_queue_t
 * thd_queue_t <|-- semaphore_t
 * thd_queue_t <|-- mutex_t
 * thd_queue_t <|-- condition_variable_t
 * 
 * thread_t <.. messages : use
 * 
 * thread_t -- events
 * thread_t o-- "0..1" mutex_t: waiting on
 * 
 * semaphore_t o-- "0..*" thread_t : waiting\nthreads
 * semaphore_t ..> CoreAPI : use
 * 
 * condition_variable_t --> thread_t : current
 * condition_variable_t ..> CoreAPI : use
 * 
 * mutex_t "1" -l- "0..*" condition_variable_t : collaboration
 * mutex_t o-- "0..*" thread_t : waiting
 * mutex_t o-- "0..1" thread_t : owner
 * mutex_t o-- "0..1" mutex_t : next owned
 * mutex_t "0..*" --o thread_t : owned
 * mutex_t ..> CoreAPI : use
 * 
 * events ..> CoreAPI : use
 * 
 * messages ..> CoreAPI : use
 * 
 * @enduml
 *
 */
